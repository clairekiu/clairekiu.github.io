<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Computer Sciences on @nimeajku</title>
    <link>https://clairekiu.github.io/computer-science/</link>
    <description>Recent content in Computer Sciences on @nimeajku</description>
    <generator>Hugo -- 0.128.2</generator>
    <language>kr-ko</language>
    <lastBuildDate>Sun, 07 Jul 2024 03:20:18 +0900</lastBuildDate>
    <atom:link href="https://clairekiu.github.io/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MST (최소신장트리), Kruskal, Prim</title>
      <link>https://clairekiu.github.io/computer-science/mst/</link>
      <pubDate>Sun, 07 Jul 2024 03:20:18 +0900</pubDate>
      <guid>https://clairekiu.github.io/computer-science/mst/</guid>
      <description>Minimum Spanning Tree 신장 트리 (Spanning Tree) 무방향 그래프 G(V, E)에서 모든 정점 V를 간선 E 중 가장 적은 갯수로 사용하여 이은 부분 그래프
n개의 정점을 가지는 그래프라면 n-1개의 간선이 사용됨 사이클을 이루지 않음 최소 신장 트리 (Minimum Spanning Tree) G(V, E)에서 간선에 가중치가 주어진 경우 선택된 간선의 가중치의 합이 최소가 되는 신장 트리
MST 구하는 알고리즘 Kruskal 사이클을 만들지 않는 선택에 한해서 가장 작은 가중치를 가지는 선을 선택해나가는 알고리즘</description>
    </item>
    <item>
      <title>Union Find (C&#43;&#43;)</title>
      <link>https://clairekiu.github.io/computer-science/union-find/</link>
      <pubDate>Sun, 07 Jul 2024 02:49:18 +0900</pubDate>
      <guid>https://clairekiu.github.io/computer-science/union-find/</guid>
      <description>Union Find Union Find: 그래프에서 두 노드가 같은 집합에 속하는지 판별하는 알고리즘 노드를 합치는 union 연산 노드가 같은 집합인지 판별하는 find 연산 구조 unionfind[i]: i번 노드의 부모 노드 정보를 담는다. unify(x, y): x번 노드와 y번 노드를 합친다. 이때 unify 이후 둘은 같은 부모 노드를 가리키게 된다. same(x, y): x번 노드와 y번 노드가 같은 집합에 있는 지 반환한다. find(x): x번 노드의 부모 노드 정보를 반환한다. 이때 unionfind[x]를 단순히 반환하는 것이 아닌, unionfind[x]를 업데이트하는 과정을 거침 재귀함수를 통해 구현하여 찾음과 동시에 부모 노드가 업데이트되도록 함 전체 코드 #include &amp;lt;iostream&amp;gt; #define MAX 100 using namespace std; using ll = long long; ll unionfind[MAX]; ll find(ll x){ if(unionfind[x]==x){ return x; } return unionfind[x]=find(unionfind[x]); } void unify(ll x, ll y){ ll n1=find(x), n2=find(y); if(n1&amp;lt;n2){ unionfind[n2]=n1; } else{ unionfind[n1]=n2; } } bool same(ll x, ll y){ return (find(x)==find(y)); } int main(){ } </description>
    </item>
  </channel>
</rss>
