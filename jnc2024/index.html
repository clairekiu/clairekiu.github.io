<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Division with Lines</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid black;
            background-color: white;
        }
        #info {
            margin: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>

    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="info">Divided Areas: 1</div>
    <button id="resetBtn">Reset Lines</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const info = document.getElementById('info');

        let drawing = false;
        let startX, startY;
        let lines = []; // 직선 데이터를 저장할 배열
        let dividedAreas = 1; // 초기에 영역은 1개

        // 원 그리기 함수
        function drawCircle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // 캔버스 초기화
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 200;

            // 원 그리기
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // 직선 그리기 함수 (화면 경계까지 확장)
        function drawStraightLine(x1, y1, x2, y2) {
            // 직선의 기울기 계산
            const slope = (y2 - y1) / (x2 - x1);
            const intercept = y1 - slope * x1;

            // 화면의 경계 좌표를 구해서 직선을 그립니다.
            const leftX = 0;
            const leftY = intercept;
            const rightX = canvas.width;
            const rightY = slope * rightX + intercept;

            // 위쪽과 아래쪽 경계 교차점 구하기
            const topY = 0;
            const topX = -intercept / slope;
            const bottomY = canvas.height;
            const bottomX = (canvas.height - intercept) / slope;

            ctx.beginPath();
            
            // 좌우 경계, 상하 경계 교차점 중 캔버스 안에 있는 점으로 선 그리기
            if (topX >= 0 && topX <= canvas.width) {
                ctx.moveTo(topX, topY);  // 상단 경계와의 교차점
            } else {
                ctx.moveTo(leftX, leftY);  // 좌측 경계와의 교차점
            }

            if (bottomX >= 0 && bottomX <= canvas.width) {
                ctx.lineTo(bottomX, bottomY);  // 하단 경계와의 교차점
            } else {
                ctx.lineTo(rightX, rightY);  // 우측 경계와의 교차점
            }

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // 전체 직선 다시 그리기
        function redrawLines() {
            lines.forEach(line => {
                drawStraightLine(line.startX, line.startY, line.endX, line.endY);
            });
        }

        // 평면 분할 개수 계산: 직선을 더할 때마다 1씩 추가
        function updateDividedAreas() {
            dividedAreas = lines.length + 1;
            info.textContent = `Divided Areas: ${dividedAreas}`;
        }

        // 마우스 이벤트
        canvas.addEventListener('mousedown', (e) => {
            drawing = true;
            startX = e.offsetX;
            startY = e.offsetY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!drawing) return;
            drawCircle();  // 원을 다시 그려서 직선이 남지 않게 함
            redrawLines();  // 기존 직선을 다시 그려줌
            drawStraightLine(startX, startY, e.offsetX, e.offsetY);
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!drawing) return;
            drawing = false;

            // 직선 데이터를 저장
            lines.push({
                startX: startX,
                startY: startY,
                endX: e.offsetX,
                endY: e.offsetY
            });

            // 직선이 추가될 때마다 분할 개수 업데이트
            updateDividedAreas();
        });

        // 초기화 버튼 기능
        resetBtn.addEventListener('click', () => {
            lines = [];
            dividedAreas = 1;
            info.textContent = `Divided Areas: ${dividedAreas}`;
            drawCircle();  // 원만 다시 그리기
        });

        // 초기 원 그리기
        drawCircle();
    </script>

</body>
</html>